var Notiffi = (function () {
  'use strict';

  /**
   * Custom method to fetch the notifications store (the original one sucks)
   * @returns {Promise} - Fetch the notifications store
   */
  async function getStore() {
    try {
      const response = await fetch("/notif");
      if (!response.ok) {
        throw new Error(`Failed to fetch: ${response.status} ${response.statusText}`);
      }

      const data = await response.json();
      return data;
    } catch (error) {
      console.error("Error fetching notifications:", error);
    }
  }

  /**
   * Delete a notification method action
   * @param {notif} notif - notification object from the store
   */
  async function deleteOne(notif) {
    const { channel, read } = notif;
    const { id } = notif.text;

    // Parse the payload
    const payload = new URLSearchParams();
    payload.append("id", id);
    payload.append("channel", channel);

    try {
      const res = await fetch(`/notif`, {
        method: "DELETE",
        headers: {
          "Content-Type": "application/x-www-form-urlencoded",
        },
        body: payload.toString(),
      });

      if (!res.ok) throw new Error(`HTTP error! status: ${res.status}`);

      // Remove the notification from the DOM
      document.querySelector(`[data-notif-id="${id}"]`).remove();

      // Update the store and the unread count
      const data = await res.json();
      return data.store;
    } catch (err) {
      console.error("Erreur lors de la suppression :", err);
    }
  }

  /**
   * Delete all notifications method action
   * (taken from the notification management page)
   */
  async function deleteAll(ids) {
    const payload = new URLSearchParams();

    // Add all the notifications to the payload
    ids.forEach((id) => payload.append("del_notif[]", id));
    payload.append("delete_all", "Tout supprimer");

    try {
      const res = await fetch(`/profile?mode=editprofile&page_profil=notifications`, {
        method: "POST",
        headers: {
          "Content-Type": "application/x-www-form-urlencoded",
        },
        body: payload.toString(),
      });

      if (!res.ok) throw new Error(`HTTP error! status ${res.status}`);
      return true;
    } catch (err) {
      console.error("Erreur lors de la suppression :", err);
    }
  }

  /**
   * Custom method action to mark a notification as read
   * @param {number} id - notification id
   */
  async function markAsRead(ids) {
    const payload = new URLSearchParams();
    ids.forEach((id) => payload.append("id[]", id));

    try {
      const res = await fetch(`/notif`, {
        method: "POST",
        headers: {
          "Content-Type": "application/x-www-form-urlencoded",
        },
        body: payload.toString(),
      });

      if (!res.ok) throw new Error(`HTTP error! status ${res.status}`);
      //return true;
    } catch {
      console.error("Erreur lors de la suppression :", err);
    }
  }

  /**
   * Fetch the user avatar from its profile page
   * @param {object} user - user object from the store
   * @returns avatar image URL
   */
  async function getUser(user) {
    const { id, name } = user;

    // Return an empty object for anonymous users
    if (name === "Anonymous") return { avatar: "", color: "" };

    // Check if the user is already in the cache avoiding a new fetch
    if (Notiffi.users[id]) return Notiffi.users[id];

    try {
      const response = await fetch(`/u${id}`);
      if (!response.ok) {
        throw new Error(`Failed to fetch: ${response.statusText}`);
      }

      const html = await response.text();
      const parser = new DOMParser();
      const doc = parser.parseFromString(html, "text/html");

      // Récupération de l'avatar
      const img = doc.querySelector(`img[alt="${name}"]`);
      const avatar = img ? `<img loading="lazy" src=${img.src} />` : "";

      // Récupération de la couleur du tag (si disponible)
      const pseudo = doc.querySelector(`span[style^="color:#"]`);
      const color = pseudo ? pseudo.style.color : "";

      // Stocker dans le cache
      Notiffi.users[id] = { avatar, color };

      return Notiffi.users[id];
    } catch (error) {
      console.error(`Error fetching avatar for user ${name}`, error);
      return null;
    }
  }

  function textNotif(notif, color) {
    const { from } = notif.text;
    return Toolbar.compileNotif(notif).replace(new RegExp(`(<a href="/u${from.id}")`, "g"), `$1 style="color: ${color}"`);
  }

  function getAward(notif) {
    return `<img src="${notif.text.award.award_image}" />`;
  }

  function createPopUp({ button, panel }) {
    const buttonElement = document.querySelector(button);
    const panelElement = document.querySelector(panel);

    if (!buttonElement || !panelElement) {
      console.error("Notiffi popup : button or panel selector not found.");
      return;
    }

    function togglepanel() {
      buttonElement.classList.toggle("active");
      panelElement.classList.toggle("open");
    }

    function closepanel() {
      buttonElement.classList.remove("active");
      panelElement.classList.remove("open");
    }

    function handleClickOutside(event) {
      if (!buttonElement.contains(event.target) && !panelElement.contains(event.target) && panelElement.classList.contains("open")) {
        closepanel();
      }
    }

    // Ajout des listeners
    buttonElement.addEventListener("click", togglepanel);
    document.addEventListener("click", handleClickOutside);
  }

  const Notiffi$1 = {
    store: [],
    syncStore: potion.sync("all_notifs", {
      notifs: [],
      isEmpty: true,
      text: "Aucune notification",
    }),
    unread: null,
    syncUnread: potion.sync("unread_notifs", { count: "" }),
    type: {
      0: {
        name: "private_msg",
        icon: '<i class="bi bi-envelope-fill"></i>',
      },
      1: {
        name: "notif_report",
        icon: '<i class="bi bi-flag-fill"></i>',
      },
      2: {
        name: "friend_request",
        icon: '<i class="bi bi-person-fill-add"></i>',
      },
      3: {
        name: "group_req",
        icon: '<i class="bi bi-people-fill"></i>',
      },
      4: {
        name: "friend_conv",
        icon: '<i class="bi bi-people-fill"></i>',
      },
      5: {
        name: "wall_msg",
        icon: '<i class="bi bi-chat-fill"></i>',
      },
      6: {
        name: "abuse",
        icon: '<i class="bi bi-flag-fill"></i>',
      },
      7: {
        name: "topic_watch",
        icon: '<i class="bi bi-chat-fill"></i>',
      },
      8: {
        name: "mention",
        icon: '<i class="bi bi-at"></i>',
      },
      9: {
        name: "hashtag",
        icon: '<i class="bi bi-hash"></i>',
      },
      10: {
        name: "advert",
        icon: '<i class="bi bi-flag-fill"></i>',
      },
      11: {
        name: "like",
        icon: '<i class="bi bi-heart-fill"></i>',
      },
      12: {
        name: "dislike",
        icon: '<i class="bi bi-heart-half"></i>',
      },
      13: {
        name: "forum_watch",
        icon: '<i class="bi bi-chat-left-fill"></i>',
      },
      14: {
        name: "new_award",
        icon: '<i class="bi bi-star-fill"></i>',
      },
      15: {
        name: "follower_new_topic",
        icon: '<i class="bi bi-chat-left-fill"></i>',
      },
      16: {
        name: "follower_new_post",
        icon: '<i class="bi bi-chat-fill"></i>',
      },
    },
    refresh: 0,
    users: {},

    init: async function (options = {}) {
      // Check if user is logged in
      if (!_userdata["session_logged_in"]) return;

      const button = options.button || "#notiffi_button";
      const panel = options.panel || "#notiffi_panel";

      createPopUp({ button, panel });

      // Actions when the Toolbar original methods are called
      // Essentials to get the live notifications updates
      const handleMethodCall = async (fnName) => {
        if (fnName === "refresh") {
          // Count the intercepted calls to avoid the first one (the first one is triggered by the page load)
          this.refresh++;

          // Fetch the notifications with a custom method
          const storeAPI = await getStore();

          // Update the store and the unread count
          this.store = storeAPI.store;
          this.displayNotifications(this.store);

          this.unread = storeAPI.unread;
          this.handleUnread(this.unread);

          // Create an alert notification with the last notification in store when it's not the first intercepted call (refresh > 1)
          if (this.refresh > 1 && !document.querySelector(`[data-notif-id="${this.store.at(-1).text.id}"]`)) {
            this.liveNotif(this.store.at(-1));
          }
        }
      };
      this.manageNotifications();

      // Toolbar proxy
      Toolbar = this.interceptMethodCalls(Toolbar, handleMethodCall);
    },

    liveNotif: async function (notif) {
      const { from, type } = notif.text;

      const { avatar, color } = await getUser(from);
      const text = textNotif(notif, color);

      const toast = potion("live_notif", {
        live: {
          type: this.type[type].name,
          icon: this.type[type].icon,
          avatar: type === 14 ? getAward(n) : avatar,
          text,
        },
      });
      const parser = new DOMParser();
      const toastNode = parser.parseFromString(toast, "text/html").body.firstChild;

      document.body.appendChild(toastNode);

      // Forcer un reflow pour garantir l'application des styles initiaux
      toastNode.getBoundingClientRect();

      // Ajouter la classe après le reflow
      requestAnimationFrame(() => {
        toastNode.classList.add("up");
      });

      setTimeout(() => {
        toastNode.classList.remove("up");
        setTimeout(() => toastNode.remove(), 1000); // Attendre la fin de l'animation
      }, 5000);

      document.body.addEventListener("click", (e) => {
        if (e.target.closest("#alert_dismiss")) {
          toastNode.classList.remove("up");
          setTimeout(() => toastNode.remove(), 1000);
        }
      });
    },

    renderNotif: async function (notifs) {
      let renderedNotifs = [];

      for (const n of notifs) {
        const { id, from, type } = n.text;

        const { avatar, color } = await getUser(from);
        const text = textNotif(n, color);

        renderedNotifs.push({
          id,
          read: n.read ? "" : "unread",
          type: this.type[type].name,
          icon: this.type[type].icon,
          avatar: type === 14 ? getAward(n) : avatar,
          text,
          time: n.time,
          async deleteNotif() {
            const data = await deleteOne(n);

            Notiffi$1.store = data;
            Notiffi$1.displayNotifications();
            Notiffi$1.handleUnread();
          },
        });
      }
      return renderedNotifs.reverse();
    },

    /**
     * Display the notifications in the notification panel
     */
    displayNotifications: async function () {
      console.log("store size", this.store.length);

      if (this.store.length === 0) {
        this.syncStore.notifs = null;
        this.syncStore.isEmpty = true;
      } else {
        this.syncStore.notifs = await this.renderNotif(this.store);
        this.syncStore.isEmpty = false;
      }
    },

    manageNotifications: function () {
      const buttons = {
        deleteAll: document.querySelector("#notiffi_delete_all"),
        markAllRead: document.querySelector("#notiffi_mark_as_read"),
      };

      for (const key in buttons) {
        const button = buttons[key];
        if (!button) {
          console.error(`NOTIFFI: Le bouton ${key} est introuvable.`);
          return;
        }

        const handlers = {
          deleteAll: async () => {
            const ids = this.store.map((notif) => notif.text.id);
            const deleted = await deleteAll(ids);
            if (deleted) {
              while (this.store.length > 0) {
                this.store.pop();
              }
              this.displayNotifications();
              this.handleUnread();
            }
          },
          markAllRead: async () => {
            const unreadNotifs = this.store.filter((notif) => !notif.read).map((notif) => notif.text.id);
            const read = await markAsRead(unreadNotifs);
            if (read) {
              this.handleUnread();
            }
          },
        };

        button.addEventListener("click", handlers[key]);
      }
    },

    /**
     * Update the unread count in the notification button
     */
    handleUnread: function () {
      const unreadCount = this.store.filter((notif) => !notif.read).length;
      this.unread = unreadCount;

      if (!unreadCount) {
        this.syncUnread.count = "";
      } else {
        this.syncUnread.count = this.unread;
      }
    },

    /**
     * Intercept method calls on the Toolbar original script and execute a function
     * @param {*} obj - Toolbar
     * @param {*} fn - function called when a method is intercepted
     * @returns {Proxy}
     */
    interceptMethodCalls: function (obj, fn) {
      return new Proxy(obj, {
        get(target, prop) {
          if (typeof target[prop] === "function") {
            return new Proxy(target[prop], {
              apply: (target, thisArg, argumentsList) => {
                fn(prop, argumentsList);
                return Reflect.apply(target, thisArg, argumentsList);
              },
            });
          } else {
            return Reflect.get(target, prop);
          }
        },
      });
    },
  };

  return Notiffi$1;

})();
